import{_ as e,o,c as t,R as a}from"./chunks/framework.V_Zt3J1u.js";const g=JSON.parse('{"title":"editor","description":"","frontmatter":{},"headers":[],"relativePath":"work/editor.md","filePath":"work/editor.md"}'),r={name:"work/editor.md"},c=a('<h1 id="editor" tabindex="-1">editor <a class="header-anchor" href="#editor" aria-label="Permalink to &quot;editor&quot;">​</a></h1><p>apps/editor，编辑器以及其他页面的存放位置。实际上编辑器页面在src/pages/editor下。</p><h2 id="src-components" tabindex="-1">src/components <a class="header-anchor" href="#src-components" aria-label="Permalink to &quot;src/components&quot;">​</a></h2><p>存放着通用的组件，如BasicLayout和BasicHeader，编辑器以外的其他地方也用到</p><h2 id="src-data" tabindex="-1">src/data <a class="header-anchor" href="#src-data" aria-label="Permalink to &quot;src/data&quot;">​</a></h2><p><code>event.ts</code>下有事件派发相关的内容，用于对元素进行事件绑定。</p><p><code>editorEvents</code>为事件的定义样例，因为在EditorRight中v-for时没有对其type进行任何限制（过滤），故所有的组件都会有common:link这个事件（不管是图片还是标题），并且Editor对应的select的位置有问题，有多少个input框就重复多少次（如标题就重复了3次），得改。</p><p><code>materials.ts</code>十分重要。在接收新的模块后，你需要在此注册模块的相关信息，包括：</p><ul><li>独一无二的id</li><li>所属栏目（category）</li><li>缩略图（thumbnail）</li><li>挂在window实例上的名称（name，如image就是LcImage，可以尝试在控制台中输入window.LcImage，看看是否有这个）</li><li>工具栏显示名称（title）</li></ul><p>等等。</p><p>至于data，是用来存放该组件的所有历史版本。如果当前缺少所需版本的组件，可以根据data里的，找到对应source，加载其他版本（功能尚未实现）。</p><h2 id="src-pages" tabindex="-1">src/pages <a class="header-anchor" href="#src-pages" aria-label="Permalink to &quot;src/pages&quot;">​</a></h2><p>类似VueRouter里使用的routes，但相比vite-plugin-page更为一体化，其下的editor所对应页面就是编辑器页面，preview就是预览页面。</p><h3 id="src-pages-editor" tabindex="-1">src/pages/editor <a class="header-anchor" href="#src-pages-editor" aria-label="Permalink to &quot;src/pages/editor&quot;">​</a></h3><p>components下定义了编辑器的左中右各部分的布局和逻辑：</p><ul><li>EditorLayout。上面我们提到BasicLayout，其中除了BasicHeader之外，剩下的部分就是EditorLayout了，它包括下面三个部分。</li><li>EditorLeft。左边栏，可以叫做工具栏、物料槽，点击、拖拽到画布即可生成物料对应的元素。其中每个按钮都由MaterialBlocks组成（在同级目录下）</li><li>EditorContent，包括页面栏、元素栏和画布（从左到右）。<code>class=&quot;editor-body-pages&quot;</code>对应div为页面栏（pages是复数可以看出），元素栏（<code>class=&quot;editor-body-elements&quot;</code>），还有画布（<code>class=&quot;editor-body-page&quot;</code>，单数page，显示当前页）。</li><li>EditorRight，点击元素时出现的属性编辑栏。当未选中元素时，则显示当前页面的名称等信息。</li></ul><p>注意，布局和逻辑是分开的，为了防止<code>.vue</code>文件的内容过长，影响查找效率，我们选择在<code>.vue</code>中<code>import</code>引入<code>.less</code>文件，而非在<code>.vue</code>中写<code>&lt;style&gt;</code>标签。</p><h2 id="src-store" tabindex="-1">src/store <a class="header-anchor" href="#src-store" aria-label="Permalink to &quot;src/store&quot;">​</a></h2><p>状态管理，包含了ProjectStore和EventStore。</p><p>因为每个元素、页面和项目之间都要通信，且要用到一些共用的功能（如更新当前选中的元素<code>setCurrentElementId()</code>、更新项目的json<code>project.value = p.getJson();</code>），因此这些都存放在<code>project.ts</code>的<code>useProjectStore</code>中。</p><p>绑定自定义事件，则在<code>event.ts</code>的useEventStore中定义相关的参数和逻辑。比如，EditorRight的面板就根据该文件的<code>currentType</code>、<code>currentEvents</code>计算属性渲染对应标签（如下拉框），切换选项时EditorRight调用<code>onTypeChange</code>更新对应计算属性<code>currentType</code>等等。</p><h2 id="public" tabindex="-1">public <a class="header-anchor" href="#public" aria-label="Permalink to &quot;public&quot;">​</a></h2><p>模块（<code>.umd.js</code>）存放位置，同时也用于放置静态文件，</p>',23),d=[c];function i(s,l,n,p,u,h){return o(),t("div",null,d)}const _=e(r,[["render",i]]);export{g as __pageData,_ as default};
