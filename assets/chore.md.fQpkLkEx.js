import{_ as a,o as e,c as t,R as o}from"./chunks/framework.V_Zt3J1u.js";const r="/low-code-docs/assets/lc-image.-OyUenb7.png",s="/low-code-docs/assets/lc-button.8NC2Xibc.png",c="/low-code-docs/assets/lc-core.kNqzjGFW.png",f=JSON.parse('{"title":"重构思路","description":"","frontmatter":{},"headers":[],"relativePath":"chore.md","filePath":"chore.md"}'),i={name:"chore.md"},n=o('<h1 id="重构思路" tabindex="-1">重构思路 <a class="header-anchor" href="#重构思路" aria-label="Permalink to &quot;重构思路&quot;">​</a></h1><h2 id="editor" tabindex="-1">editor <a class="header-anchor" href="#editor" aria-label="Permalink to &quot;editor&quot;">​</a></h2><h2 id="组件-插件包第三方化" tabindex="-1">组件/插件包第三方化 <a class="header-anchor" href="#组件-插件包第三方化" aria-label="Permalink to &quot;组件/插件包第三方化&quot;">​</a></h2><h3 id="单组件仓库-改为-多组件仓库" tabindex="-1">单组件仓库 改为 多组件仓库 <a class="header-anchor" href="#单组件仓库-改为-多组件仓库" aria-label="Permalink to &quot;单组件仓库 改为 多组件仓库&quot;">​</a></h3><p>开发环境仍要手动导<code>umd.js</code>，因为前端项目只能指定路径而不能全部导入或者正则匹配。</p><p>一个简单的思路是做成接口，需要后端返回对应脚本url数组，但这样对第三方开发并不友好。不过这种形式以后一定会用到，可以留意。</p><p>另一个简单的思路就是将<strong>每个仓库只能有一个组件</strong>改为<strong>每个仓管可以有多个组件</strong>，当组件增删时，不需要自己手动添加或删除。</p><p>加之创建仓库其实是很麻烦的操作，与高效开发背道而驰。于是采用了上面的方案二。</p><p>这样做的好处还有大幅减少体积。以下是image、button和包含以上两个组件的core打包后的大小：</p><p><img src="'+r+'" alt="lc-image.umd.js"></p><p><img src="'+s+'" alt="lc-button.umd.js"></p><p><img src="'+c+'" alt="core.umd.js"></p><p>不过限制也有，那就是插件包信息必须是全量导入的。幸好导入的只是信息（包含了脚本地址），而不是组件，所以注意不要全量挂载即可。</p><h3 id="配置外置化" tabindex="-1">配置外置化 <a class="header-anchor" href="#配置外置化" aria-label="Permalink to &quot;配置外置化&quot;">​</a></h3><p>编辑器不应有任何关于组件、package的配置，目前编辑器和packages是耦合在一起的，编辑器内置了组件的类型、ID、历史版本，这些信息后续都会放到packages配置组件的地方，确保一个组件的ID、版本号等唯一信息不要出现在两个地方。</p>',15),d=[n];function l(p,h,_,m,u,g){return e(),t("div",null,d)}const k=a(i,[["render",l]]);export{f as __pageData,k as default};
